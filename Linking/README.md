# Linking 

Linking is the process of collecting and combing various pieces of code and data **into a single file** that can be loaded(copied) into memory and executed. `Linking can be performed at compile time`:

+ when the source code is translated into machine code; 
+ at load time, when the program loaded into memory and executed by the loader;
+ at runtime, by application programs

Linker plays a crucial role in software development because they enable ***separate compilation***. Instead of organizing a large application as one monolithic source file, we can **decompose it into smaller, more manageable modules** that can be modified and compiled separately. When we change one of these modules, we simply recomile it and relink the application, without having to recompile the other files. 

 Most compilation systems provide a **compiler driver** that invokes:

```txt
Language Preprocessor -> Compiler -> Assembler -> Linker -> Executable Object file
```

For example: when you compile c program in linux system(assume we have two c files right now, where `main.c` call the function that from `sum.c`)

```bash
linux > gcc -Og -o prog main.c sum.c
```

1. The driver first runs the **C preprocessor**, which translates the C source file `main.c `into an ***ASCII intermediate file*** `main.i(/tmp/main.i)`

2. The dirver runs the **C compiler**(`cc1`), whch translate `main.i ` into an ***ASCII assembly-language file*** `main.s`:

   ```bash
   cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s
   ```

3. The driver runs the assembler, which translates `main.s` into a ***binary relocatable object file*** `main.o`<br>(`tmp/main.s` -> `tmp/main.o`).

3. The driver goes through the same process to generate `sum.o` 

4. Finally, it runs the ***linker program Id***, which **combines maino and sum.o**, along with the necessary system object files, to create ***the binary executable object file*** `prog`:

   ```bash
   ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o
   ```

5. Run the executable file `prog`

   ```bash
   linux > ./prog
   ```

![the_driver_translate_process](./pic/the_driver_translates_process.png)

<p align="center">This figure comes from <a href = "https://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/13-linking.pdf">cmu-213 slide</a></p>

### Why Linkers?

1. Modulartity:
   + Program can be written as a collection of smaller source files, rather than one monolithc mass
   + Can build libraries of common functions
2. Efficiency:
   + Time - Separate compilation: when change one source file, we just compile the changed file and no need to recompile other source files.
   + Space - Libraries
     + Common functions can be aggregated into a single file
     + Yet executable files and running memory images **contain only code for the functions they actually use**.

## What Do Linkers Do?

Static linkers such as LD program in Linux takes as input a collection of **relocatable obejct files** and **command-line arguements** to generate as output a fully linked executable object file that can be loaded and run.

+ The input **relocatable object files** consist of **various code** and **data sections**, where each section is a contiguous sequence of bytes. 

The linker performs two main tasks:

1. ***Symbol resolution***:  

   Object files define and reference symbols, where each symbol corresponds to a function, a global variable or static variable. In other words, in this step, the linker has to decide which definitions to use for all subsequent reference. **The purpose of symbol resolution is to associate each symbol reference with exactly one symbol definition.** 

   For symbol defition, it stored in object file(by assembler) in symbol table:

   + Symble table is an array of structs
   + Each entry includes name, size, and location of symbol.

   ```c
   void swap {...} 	// define symbol swap
   swap();						// reference symbol swap
   int *xp = &x			// define symbol xp, reference x
   ```

2. **Relocation:**

   The linker decides on where each symbol is going to be ulmimately located in memory, when the program executes. And binds that those absolute memory locations to the symbol. Then it goes and looks at all the reference to those symbols, points to the right spot in the final.

   + Compilers and assemblers generate code and data sections that start at address 0 and meges separate code and data sections into single sections.

   + The linker relocates these sections by associating at memory location with symbol definition(from their relative locations in the `.o` files to their final absolute memory location in the executable)
   + Then modifing all of the references to those symbols so that they point to this memory location. The linker blindly performs these relocations using detailed instructions, generated by the assemler, called relocation entires.

   Note that: Functions are just stored at some offset in their object module, because the linker doesn't know where those functions are actually going to be eventually a loaded into memory. Before relocation the address of, a function in the object module is just its offset in the module and similarly for data

## The type of object files

+ **Relocatable object file(`.o` file):** contain binary code and data in a form that can be combined with other relocatable object files to form executable object file, where the relocatable object file is the **output by assembler** and **it cannot be directly access by memory**.
  + Each` .o` file is produced from exactly one source `.c` file

+ **Executable object file(`.out` file)**: contains binary code and data in a form that can be copied directly into memory and then executed.
+ **Shared object file(`.so` file)**: a special type of relocatable object file that can be **loaded into memory and linked dynamically,** at either load time or run-time
  + Called ***Dynamic Link Libraries(DLLs)*** by Windows

Technically, an **object module** is a sequence of bytes and an **object file** is an object module stored on disk in a file. Object files are organized according to specific object file formats, which vary from system to sytem:

+ In first Unix systems from Bell labs used `a.out` format
+ Windows uses the **Portable Executable(PE)** format.
+ Mac OS uses **Mach-O** format
+ Modern x86-64 Linux and Unix systems use **Executable and Linkable Format(ELF)**.

The basic concepts are similar, regardless of the particular format.

![elf_format_1](./pic/elf_format_1.png)

<p align="center">This figure comes from <a href = "https://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/13-linking.pdf">cmu-213 slide</a></p>

+ `.bss`: Uninitialized global and static C variables, along with any global or static variables that are initialized to zero. **This section occupies no actual space in the object file;** it is merely a placeholder. Object file formats distinguish between initialized and uninitialized variable for space efficiency: uninitialized variable do not have to occupy any actual disk space in the object file. **At run time, these variable are allocated in memory with an initial value of zero.**

![elf_format_2](./pic/elf_format_2.png)

<p align="center">This figure comes from <a href = "https://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/13-linking.pdf">cmu-213 slide</a></p>

+ `.symtab`: A symbol table with information about functions and global variables that are defined and referenced in that program. Some programmers mistakenly believe that a program must be compiled with `-g` option to get symbol table information. In fact, **every relocatable object file has a symbol table in `.symtab`**(unless the programmer has specifcally removed it with `STRIP` command). However, unlike the symbol table inside a compiler, **the `.symtab` symbol table does not  contain entries for local variable.**
+ `.rel.text`: **A list of locations** in the `.text` section that will need to be modified when the linker combines this object file with others. In general, any instruction that calls an `external function` or `references a global variable` will need to be modified. On the other hand, **instructions that call local function do not need to be modified.** Note that relocation infomation is not needed in executable object files, and is usually omitted unless the user explicitly instructs the linker to include it.
+ `.rel.data`:Relocations information for any global variables that are referenced or defined by the module. In general, any initialized global variable whose initial value is the address of a global variable or externally defined function will need to be modified.
+ `.debug`: A debugging symbol table with entries for **local variables** and **typedefs defined** in the program, **global variable defined and referenced** in the program, and the original C source file. It is only present if the compiler driver is invoked with the `-g` flag.
+ `.line` : A **mapping** between **line numbers in the original C source program** and **machine code instructions** in the `.text` section. It is only present if the compiler driver is invoked with the `-g` flag.
+ `.strlab`: A **string table for the symbol tables** in the `.symtab` and `.debug` section and for the section names in the section headers. A string table is a sequence of null-terminated character strings.

## Linker Symbols

Symbol table are **built by assembler**, using symbols exported by the compiler in the assembly-language `.s` file. All ELF symbol table is contained in the `.symtab` section, where it contains an array of entries.

```c
typedef struct{
  int	name;	    // String table offset
  char	type:4,	    // Function or Data(4 bits)
  		binding: 4;	// Local or global(4 bits)
  char 	reserved; 	// Unused
  short section;	// Section header index
  long	value;		// Section offset or absolute address
  long 	size;		// Object size in bytes
} Elf64_Symbol;
```

<p align="center">Elf symbol table entry</p>

Note that **these psudosection exist only in relocated object file** and do not exist in the executable object file.

+ The `name `of a byte offset into the string table that points to the null-terminated string name of the symbol. 
+ The `value `is the symbol's address.

+ For **relocatable modules**, the `value `is an **offset from the beginning of the section** where the object is defined.

+ For **executable object files**, the `value `is an **absolute run-time address**.

+ The `size `is the size(in byte) of the object.

+ The `type `is usually either ***data*** or ***function***. The symbol table can also contain entires for the **individual sections** and for **the path name** of the original source file, so there are **distinct types for these object** as well.

+ The `binding field` indicates whether symbol is local or global.

+ Each symbol is assigned to some sectoin of the object file, denoted by the `section` field, which is an index into the section header table.

  There have 3 special pseudosections that don't have entries in the section header table:

  + `ABS `is for symbols that should not be relocated.
  + `UNDEF `is for undefined symbol -- that is, symbols that are referenced in this object module but defined elsewhere.
  + `COMMON `is for uninitialized data objects that are not yet allocated.  For the `COMMON` symbol,  the `value `field gives the alignment requirement, and `size `gives the minimum size.

The distinction between `COMMON `and `.bss` is:

+ `COMMON `: Uninitialized global variables
+ `.bss` : Uninitialzed static variables, and global or static variables that are initialized to zero.

### 1. Global symbols

Global symbols **defined** by module `m `and that **can be referenced by other modules**. Global linker symbols correspond to ***nostatic*** C functions and global variables.

### 2. External symbols

Global symbols **referenced** by module `m`, but **defined by some other modules**, where it also corresponds to nostatic and that global variables that are defined in other modules.

### 3. Local symbols

Local symbols that are defined and referenced exclusively by module `m`. There correspond to ***static C function*** and global variables that are defined with **the static attribute**. These symbols are visible anywhere within the module `m`, but **cannot be referenced by other modules**.

**Note that:**

+ **Local linker symbols are not local program variables**, where the symbol table in `.symtab` **does not contain any symbols that correspond to local nostatic program variable**. The **local C variable are managed by compiler *on the stack***, and thus linker has no idea about local C variable.

+ Similarly, local procedure variables that are defined with C static attribute are not managed on the stack. Instead, **the compiler allocates space in `.data` or `.bss` for each definetion and creates a local linker symbol** in the symbol table with a unique name.

## How Linker Resolve Duplicate Symbol Names

When the compiler encounters a symbol(either a variable or function name) that is not defined in the current module, it assumes that it is defined in some other module, generates a linker symbol table entry and leave it for the linker to handle.

For multiple object modules, global symbols can be defined as the same name. Under such circumstances, the linker must either flag an error or somehow chooes one of the definetion and discard the rest.

![symbol_resolution](./pic/symbol_resolution.png)

<p align="center">This figure comes from <a href = "https://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/13-linking.pdf">cmu-213 slide</a></p>

If the linker in unable to find a definition for the referenced symbol in any of its input modules, it prints an (often crypic) error message and terminates.
